/*
 * This file defines an example yacc grammar for simple C expressions.
 */

%{
	#include <stdio.h>
	int sym[26] =  {0};
%}

%union {
  int num;
}

%token <num> NUM
%token <num> VAR

%token<num> LSHIFT
%token<num> RSHIFT

%token<num> DUMP
%token<num> CLEAR

%token<num> ASSIGN

%type <num> token

%type <num> expr
%type <num> expr1
%type <num>	expr2
%type <num> expr3
%type <num> expr4
%type <num> expr5
%type <num> expr6
%type <num> expr7
%type <num> expr8
%type <num> expr9
//%left '+' '*'


%%
commands:	command	';'
		|	commands command ';'
		;

command	:	expr				{ printf("%d\n", $1); }
		|	DUMP				{	
									size_t i = 0;
									for( i = 0 ; i < 26 ; ++i) 
									{
										char toke = i + 'a';
										printf("%c: %d\n",  toke, + sym[i]);
									}
								}
		|	CLEAR				{	memset(sym, 0x0, sizeof(int)*26); }

		/*|	VAR '='	expr		{ sym[$1] = $3;}*/		
		|	VAR ASSIGN expr		{
									int flag = $2;
									int * curr = sym + $1;
									

									switch(flag)
									{
										case (int) '+':
											*curr = *curr + $3;
											break;
										
										case (int) '-':
											*curr = *curr - $3;
											break;

										case (int) '*':
											*curr = (*curr) * $3;
											break;	
										
										case (int) '/':
											*curr = *curr / $3;
											break;
										
										case (int) '%':
											*curr = *curr % $3;
											break;
										
										case (int) '<':
											*curr = *curr << $3;
											break;
										
										case (int) '>':
											*curr = *curr >> $3;
											break;

										case (int) '&':
											*curr = *curr & $3;
											break;

										case (int) '^':
											*curr = *curr ^ $3;
											break;

										case (int) '|':
											*curr = *curr | $3;	
											break;
									}
								}
	;





expr	:	/*token				{ $$ = $1; }	*/
		VAR					{ $$ = sym[$1]; }
		|	NUM					{ $$ = $1;		}
		
		|   expr1				{ $$ = $1;		}
		|	VAR	'='	expr1		{ sym[$1] = ($3);	}
		/*|	expr1 '+' expr		{ $$ = ($1) + ($3); }
		|	expr1 '-' expr		{ $$ = ($1) - ($3);	}
		*/
		;

// bitwise pr
expr1	:	expr2				{ $$ = $1; }
		|	expr2 '|' token		{ $$ = ($1) | ($3);		}
		;


// bitwise xor
expr2	:	expr3				{ $$ = $1; }
		|	expr3 '^' token		{ $$ = ($1) ^ ($3);		}
		;

// bitwise and
expr3	:	expr4				{ $$ = $1; }
		|	expr4 '&' token		{ $$ = ($1) & ($3);		}
		;


// shifts
expr4	:	expr5				{ $$ = $1; }
		|	expr5 LSHIFT expr	{ $$ = ($1) << ($3);	}
		|	expr5 RSHIFT expr	{ $$ = ($1) >> ($3);	}
		;


// plut minus
expr5	:	expr6				{ $$ = $1;	}
		|	expr6 '+' token		{ $$ = ($1) + ($3);		}
		|	expr6 '-' token		{ $$ = ($1) - ($3);		}

// mult divide modulo
expr6	:	expr7				{ $$ = $1;}
		|	expr7 '*' token		{ $$ = ($1) * ($3); }
		|	expr7 '/' token		{ $$ = ($1) / ($3); }
		|	expr7 '%' token		{ $$ = ($1) % ($3); }
		;



// negation
expr7	:	expr8				{ $$ = $1; }
		|	'-' expr8			{ $$ = -($2);	}
		/*|	'-' token			{ $$ = -($2);	}*/
		;

// bitwise not
expr8	:	expr9				{ $$ = $1;		}
		|	'~' expr9			{ $$ = ~($2);	}
		/*|	'~' token			{ $$ = ~($2);	}*/
		;

// parens
expr9	:	expr				{ $$ = $1;		}
		|	'(' expr ')'		{ $$ = $2;		}
		;



token	:	NUM		{ $$ = $1;		}
		|	VAR		{ $$ = sym[$1]; }
		;



%%

main()
{
   if (yyparse())
      printf("\nInvalid expression.\n");
   else
      printf("\nCalculator off.\n");
}

yyerror(s)
char *s;
{
   fprintf(stderr, "%s\n", s);
}
